import java.text.SimpleDateFormat
import java.util.concurrent.TimeUnit

def dockerBuildVersion = project.hasProperty('release.releaseVersion') ? project.property('release.releaseVersion') : "${rootProject.version}"
def dockerOrgName = project.hasProperty('dockerOrgName') ? project.getProperty("dockerOrgName") : "hyperledger"
def dockerArtifactName = project.hasProperty("dockerArtifactName") ? project.getProperty("dockerArtifactName") : "besu"
def dockerImageName = "${dockerOrgName}/${dockerArtifactName}"

// set the shell command to use according to os
def shell = org.gradle.internal.os.OperatingSystem.current().isWindows() ? "${projectDir}\\wslsh.bat" : '/bin/bash'

// http://label-schema.org/rc1/
// using the RFC3339 format "2016-04-12T23:20:50.52Z"
def buildTime() {
    def df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
    df.setTimeZone(TimeZone.getTimeZone("UTC"))
    return df.format(new Date())
}

// rename the top level dir from besu-<version> to besu and this makes it really
// simple for use in docker
tasks.register("dockerDistUntar") {
    dependsOn distTar
    dependsOn distZip
    def dockerBuildDir = "build/docker-besu/"
    def distTarFile = distTar.outputs.files.singleFile
    def distTarFileName = distTar.outputs.files.singleFile.name.replace(".tar.gz", "")

    doFirst {
        new File(dockerBuildDir).mkdir()
        copy {
            from tarTree(distTarFile)
            into(dockerBuildDir)
        }
        project.delete(files("${dockerBuildDir}/besu"))
        file("${dockerBuildDir}/${distTarFileName}").renameTo("${dockerBuildDir}/besu")
    }
}

tasks.register('distDocker') {
    dependsOn dockerDistUntar
    inputs.dir("build/docker-besu/")
    def dockerBuildDir = "build/docker-besu/"

    doLast {
        copy {
            from file("${projectDir}/docker/Dockerfile")
            into(dockerBuildDir)
        }
        exec {
            def image = "${dockerImageName}:${dockerBuildVersion}"
            def dockerPlatform = ""
            if (project.hasProperty('docker-platform')){
                dockerPlatform = "--platform ${project.getProperty('docker-platform')}"
                println "Building for platform ${project.getProperty('docker-platform')}"
            }
            def gitDetails = getGitCommitDetails(7)
            executable shell
            workingDir dockerBuildDir
            args "-c", "docker buildx build ${dockerPlatform} --build-arg BUILD_DATE=${buildTime()} --build-arg VERSION=${dockerBuildVersion} --build-arg VCS_REF=${gitDetails.hash} -t ${image} ."
        }
    }
}

tasks.register('testDocker') {
    dependsOn distDocker
    def expectedOutput = "Ethereum main loop is up"
    def image = "${dockerImageName}:${dockerBuildVersion}"

    def timeoutSeconds = 15
    def profilesFolder = file('linea-besu/profiles')

    doLast {
        if (!profilesFolder.exists() || !profilesFolder.isDirectory()) {
            throw new GradleException("Profile folder does not exist or is not a directory: ${profilesFolder}")
        }

        def profiles = profilesFolder.listFiles().findAll { it.name.endsWith('.toml') }
        if (profiles.isEmpty()) {
            throw new GradleException("No TOML files found in folder: ${profilesFolder}")
        }
        println "Testing profiles startup:"

        def failedProfiles = []

        profiles.each { profile ->
            def fileNameWithoutExtension = profile.name[0..-6] // Remove the '.toml' extension

            def output = new ByteArrayOutputStream()
            def errorOutput = new ByteArrayOutputStream()
            def process = ["sh", "-c", "docker run --rm -e BESU_PROFILE=${fileNameWithoutExtension} ${image} "].execute()
            process.consumeProcessOutput(output, errorOutput)

            def startTime = System.currentTimeMillis()
            def found = false

            while ((System.currentTimeMillis() - startTime) < TimeUnit.SECONDS.toMillis(timeoutSeconds)) {
                def actualOutput = output.toString().trim()
                if (actualOutput.contains(expectedOutput)) {
                    found = true
                    break
                }
                if (!process.isAlive()) {
                    break
                }
                Thread.sleep(1000) // Sleep for 1 second before checking again
            }

            process.waitForOrKill(TimeUnit.SECONDS.toMillis(1))

            if (!found) {
                def actualOutput = output.toString().trim()
                def errorMsg = errorOutput.toString().trim()
                println "${profile.name}: FAILED"
                println("Expected: '${expectedOutput}', but got: '${actualOutput}'. Error: '${errorMsg}'")
                failedProfiles.add(profile.name)
            } else {
                println "${profile.name}: PASSED"
            }
        }

        if (!failedProfiles.isEmpty()) {
            throw new GradleException("Some profiles failed: ${failedProfiles.join(', ')}")
        }
    }
}

tasks.register('publishDocker') {
    dependsOn distDocker
    doLast {
        exec {
            def image = "${dockerImageName}:${dockerBuildVersion}"
            executable shell
            args "-c", "docker push ${image}"
        }
    }
}

def getGitCommitDetails(length = 8) {
    try {
        def gitFolder = "$projectDir/.git/"
        if (!file(gitFolder).isDirectory()) {
            gitFolder = file(gitFolder).text.substring(length).trim() + "/"
        }
        def takeFromHash = length
        def head = new File(gitFolder + "HEAD").text.split(":")
        def isCommit = head.length == 1

        def commitHash, refHeadFile
        if (isCommit) {
            commitHash = head[0].trim().take(takeFromHash)
            refHeadFile = new File(gitFolder + "HEAD")
        } else {
            refHeadFile = new File(gitFolder + head[1].trim())
            commitHash = refHeadFile.text.trim().take(takeFromHash)
        }

        // Use head file modification time as a proxy for the build date
        def lastModified = new Date(refHeadFile.lastModified())
        // Format the date as "yy.M" (e.g. 24.3 for March 2024)
        def formattedDate = new SimpleDateFormat("yy.M").format(lastModified)

        return [hash: commitHash, date: formattedDate]
    } catch (Exception e) {
        logger.warn('Could not calculate git commit details, using defaults (run with --info for stacktrace)')
        logger.info('Error retrieving git commit details', e)
        return [hash: "xxxxxxxx", date: "00.0"]
    }
}